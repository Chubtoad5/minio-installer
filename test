#!/bin/bash
#
# MinIO single-node installer (Air-gap & Registry ready)
# Merges logic from rke2-installer for offline/registry handling
#

# --- Script Configuration --- #
set -o errexit
set -o nounset
set -o pipefail

# --- User Defined Variables --- #
DEBUG=${DEBUG:-1}

# MinIO Versions
MINIO_VERSION=${MINIO_VERSION:-"latest"}
MC_VERSION=${MC_VERSION:-"latest"}
# Docker Version for offline packing (Static binary version)
DOCKER_STATIC_VERSION=${DOCKER_STATIC_VERSION:-"24.0.5"}

# Service identity / TLS
MINIO_FQDN=${MINIO_FQDN:-"minio.edge.lab"}
MINIO_WILDCARD_DOMAIN=${MINIO_WILDCARD_DOMAIN:-"*.edge.lab"}
BIND_ADDRESS=${BIND_ADDRESS:-"$(hostname -I | awk '{print $1}')"}

# Certificate subject
COUNTRY=${COUNTRY:-"US"}
STATE=${STATE:-"MA"}
LOCATION=${LOCATION:-"BOSTON"}
ORGANIZATION=${ORGANIZATION:-"SELF"}
DURATION_DAYS=${DURATION_DAYS:-"3650"}

# MinIO admin credentials
MINIO_ROOT_USER=${MINIO_ROOT_USER:-"minioadmin"}
MINIO_ROOT_PASSWORD=${MINIO_ROOT_PASSWORD:-"minioadmin123"}

# Default bucket
MINIO_DEFAULT_BUCKET=${MINIO_DEFAULT_BUCKET:-"default-bucket"}

# Ports
MINIO_S3_PORT=${MINIO_S3_PORT:-"9000"}
MINIO_CONSOLE_PORT=${MINIO_CONSOLE_PORT:-"9001"}

# Paths
MINIO_BASE_DIR=${MINIO_BASE_DIR:-"/opt/minio"}
MINIO_DATA_DIR=${MINIO_DATA_DIR:-"$MINIO_BASE_DIR/data"}
MINIO_CERT_DIR=${MINIO_CERT_DIR:-"$MINIO_BASE_DIR/certs"}
MINIO_COMPOSE_FILE=${MINIO_COMPOSE_FILE:-"$MINIO_BASE_DIR/docker-compose.yml"}
MINIO_CONTAINER_NAME=${MINIO_CONTAINER_NAME:-"minio-server"}

# --- INTERNAL VARIABLES --- #
base_dir=$(pwd)
WORKING_DIR="$base_dir/minio-install-files"
current_hostname=$(hostname)

# Mode Flags
INSTALL_MODE=0
UNINSTALL_MODE=0
SAVE_MODE=0
AIR_GAPPED_MODE=0
REGISTRY_MODE=0

# Registry Vars
REGISTRY_INFO=""
REG_FQDN=""
REG_PORT=""
REG_USER=""
REG_PASS=""
MINIO_IMAGE="minio/minio:${MINIO_VERSION}"
MC_IMAGE="minio/mc:${MC_VERSION}"

# Patterns
fqdn_pattern='^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$'
ipv4_pattern='^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'

# --- Utility Functions --- #

debug_run() {
  if [ "$DEBUG" -eq 1 ]; then
    echo "--- DEBUG: Running '$*' ---"
    "$@"
    local status=$?
    echo "--- DEBUG: Finished '$*' with status $status ---"
    return $status
  else
    "$@" >/dev/null 2>&1
    return $?
  fi
}

check_root_privileges() {
  if [[ $EUID != 0 ]]; then
    echo "This script must be run with sudo or as the root user."
    exit 1
  fi
}

os_check() {
    if [[ -f /etc/os-release ]]; then
        source /etc/os-release
        OS_ID="${ID:-}"
    else
        echo "Unknown or unsupported OS."
        exit 1
    fi
}

# --- Docker Installation (Online & Offline) --- #

install_docker() {
    if command -v docker >/dev/null 2>&1; then
        echo "Docker is already installed."
        return 0
    fi

    echo "Docker not found. Installing..."
    
    if [[ "$AIR_GAPPED_MODE" -eq 1 ]]; then
        echo "  [Offline] Installing Docker from static binaries..."
        # Extract static binaries
        tar -xzf "$WORKING_DIR/docker-static.tgz" -C "$WORKING_DIR"
        cp "$WORKING_DIR/docker/"* /usr/bin/
        
        # Create Systemd Unit
        cat > /etc/systemd/system/docker.service <<EOF
[Unit]
Description=Docker Application Container Engine
Documentation=https://docs.docker.com
After=network-online.target firewalld.service
Wants=network-online.target

[Service]
Type=notify
ExecStart=/usr/bin/dockerd
ExecReload=/bin/kill -s HUP \$MAINPID
LimitNOFILE=infinity
LimitNPROC=infinity
TimeoutStartSec=0
Delegate=yes
KillMode=process
Restart=on-failure
StartLimitBurst=3
StartLimitInterval=60s

[Install]
WantedBy=multi-user.target
EOF
        systemctl daemon-reload
        systemctl enable --now docker
        
    else
        echo "  [Online] Installing Docker via convenience script..."
        curl -fsSL https://get.docker.com | sh
        systemctl enable --now docker
    fi

    echo "Docker installed successfully."
}

# --- Registry & Image Handling --- #

configure_registry_and_images() {
    # 1. Trust Registry CA if provided
    if [[ "$REGISTRY_MODE" -eq 1 ]]; then
        echo "  Configuring trust for registry: $REGISTRY_INFO"
        # Create docker certs dir
        local cert_dir="/etc/docker/certs.d/${REG_FQDN}:${REG_PORT}"
        mkdir -p "$cert_dir"
        
        # Fetch CA (borrowed from rke2-installer logic)
        if openssl s_client -showcerts -connect "$REGISTRY_INFO" < /dev/null 2>/dev/null | openssl x509 -outform PEM > "$cert_dir/ca.crt"; then
            echo "  Registry CA saved to $cert_dir/ca.crt"
        else
            echo "WARNING: Could not fetch CA from registry. Proceeding insecurely or relying on system trust."
        fi

        # Login
        echo "  Logging into registry..."
        echo "$REG_PASS" | docker login "$REGISTRY_INFO" -u "$REG_USER" --password-stdin
    fi

    # 2. Load Images (Offline Mode)
    if [[ "$AIR_GAPPED_MODE" -eq 1 ]]; then
        echo "  [Offline] Loading images from archive..."
        docker load -i "$WORKING_DIR/images/minio-images.tar"
    elif [[ "$REGISTRY_MODE" -eq 1 ]]; then
        # Online but pushing to registry -> Pull first
        echo "  [Online] Pulling upstream images..."
        docker pull "minio/minio:${MINIO_VERSION}"
        docker pull "minio/mc:${MC_VERSION}"
    fi

    # 3. Retag and Push (Registry Mode)
    if [[ "$REGISTRY_MODE" -eq 1 ]]; then
        echo "  Pushing images to private registry..."
        
        # Retag
        local new_minio="${REG_FQDN}:${REG_PORT}/minio/minio:${MINIO_VERSION}"
        local new_mc="${REG_FQDN}:${REG_PORT}/minio/mc:${MC_VERSION}"
        
        docker tag "minio/minio:${MINIO_VERSION}" "$new_minio"
        docker tag "minio/mc:${MC_VERSION}" "$new_mc"
        
        # Push
        docker push "$new_minio"
        docker push "$new_mc"
        
        # Update Global Image Vars for Compose
        MINIO_IMAGE="$new_minio"
        MC_IMAGE="$new_mc"
    fi
}

get_compose_cmd() {
  if docker compose version >/dev/null 2>&1; then echo "docker compose"; 
  elif command -v docker-compose >/dev/null 2>&1; then echo "docker-compose"; 
  else return 1; fi
}

# --- Offline Prep (Save) --- #

run_save() {
    echo "--- Starting Offline Preparation ---"
    mkdir -p "$WORKING_DIR/images"
    
    # 1. Download Docker Binaries
    echo "  Downloading Docker Static Binaries ($DOCKER_STATIC_VERSION)..."
    curl -sfL "https://download.docker.com/linux/static/stable/x86_64/docker-${DOCKER_STATIC_VERSION}.tgz" -o "$WORKING_DIR/docker-static.tgz"

    # 2. Check local docker to pull images
    if ! command -v docker >/dev/null 2>&1; then
        echo "Error: Docker required on this host to pull images for the save package."
        exit 1
    fi

    # 3. Pull and Save Images
    echo "  Pulling MinIO images..."
    docker pull "minio/minio:${MINIO_VERSION}"
    docker pull "minio/mc:${MC_VERSION}"
    
    echo "  Saving images to archive..."
    docker save "minio/minio:${MINIO_VERSION}" "minio/mc:${MC_VERSION}" -o "$WORKING_DIR/images/minio-images.tar"

    # 4. Create Final Archive
    echo "  Creating 'minio-save.tar.gz'..."
    tar -czf minio-save.tar.gz minio-install-files "$0"
    
    echo "--- Offline Package Created: minio-save.tar.gz ---"
    echo "Transfer this file to your air-gapped host."
    rm -rf "$WORKING_DIR"
}

# --- MinIO Setup Functions --- #

validate_dns() {
  echo "Validating DNS for '$MINIO_FQDN'..."
  local dns_ip
  dns_ip=$(getent ahosts "$MINIO_FQDN" 2>/dev/null | awk '/STREAM/ {print $1; exit}')

  if [[ -z "$dns_ip" ]]; then
    echo "WARNING: DNS lookup failed. Ensure local /etc/hosts is updated."
  elif [[ "$dns_ip" != "$BIND_ADDRESS" ]]; then
    echo "WARNING: DNS resolves to $dns_ip, but bind address is $BIND_ADDRESS."
  else
    echo "DNS validation successful."
  fi
}

generate_certs() {
  echo "Creating self-signed certificate..."
  mkdir -p "$MINIO_CERT_DIR/CAs"
  mkdir -p "$base_dir/tmp_certs"

  openssl genrsa -out "$base_dir/tmp_certs/ca.key" 4096
  openssl req -x509 -new -nodes -sha512 -days "$DURATION_DAYS" \
    -subj "/C=$COUNTRY/ST=$STATE/L=$LOCATION/O=$ORGANIZATION/CN=$MINIO_WILDCARD_DOMAIN" \
    -key "$base_dir/tmp_certs/ca.key" \
    -out "$base_dir/tmp_certs/ca.crt"

  openssl genrsa -out "$base_dir/tmp_certs/private.key" 4096
  openssl req -sha512 -new \
    -subj "/C=$COUNTRY/ST=$STATE/L=$LOCATION/O=$ORGANIZATION/CN=$MINIO_WILDCARD_DOMAIN" \
    -key "$base_dir/tmp_certs/private.key" \
    -out "$base_dir/tmp_certs/minio.csr"

  cat >"$base_dir/tmp_certs/v3.ext" <<EOF
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names
[alt_names]
DNS.1 = $MINIO_WILDCARD_DOMAIN
DNS.2 = $MINIO_FQDN
DNS.3 = $current_hostname
IP.1  = $BIND_ADDRESS
EOF

  openssl x509 -req -sha512 -days "$DURATION_DAYS" \
    -extfile "$base_dir/tmp_certs/v3.ext" \
    -CA "$base_dir/tmp_certs/ca.crt" \
    -CAkey "$base_dir/tmp_certs/ca.key" \
    -CAcreateserial \
    -in "$base_dir/tmp_certs/minio.csr" \
    -out "$base_dir/tmp_certs/public.crt"

  cp "$base_dir/tmp_certs/public.crt" "$MINIO_CERT_DIR/public.crt"
  cp "$base_dir/tmp_certs/private.key" "$MINIO_CERT_DIR/private.key"
  cp "$base_dir/tmp_certs/ca.crt" "$MINIO_CERT_DIR/CAs/ca.crt"
  
  # Ensure certs are readable by MinIO (UID 1000)
  chmod -R 755 "$MINIO_CERT_DIR"
  chown -R 1000:1000 "$MINIO_CERT_DIR"
  rm -rf "$base_dir/tmp_certs"
}

generate_compose_file() {
  echo "Generating docker-compose.yml using image: $MINIO_IMAGE"
  mkdir -p "$MINIO_BASE_DIR"

  cat >"$MINIO_COMPOSE_FILE" <<EOF
services:
  minio:
    image: ${MINIO_IMAGE}
    container_name: ${MINIO_CONTAINER_NAME}
    hostname: ${current_hostname}
    restart: unless-stopped
    command: server /data --console-address ":9001" --certs-dir /certs
    environment:
      MINIO_ROOT_USER: "${MINIO_ROOT_USER}"
      MINIO_ROOT_PASSWORD: "${MINIO_ROOT_PASSWORD}"
      MINIO_SERVER_URL: "https://${MINIO_FQDN}:${MINIO_S3_PORT}"
      MINIO_BROWSER_REDIRECT_URL: "https://${MINIO_FQDN}:${MINIO_CONSOLE_PORT}"
    ports:
      - "${BIND_ADDRESS}:${MINIO_S3_PORT}:9000"
      - "${BIND_ADDRESS}:${MINIO_CONSOLE_PORT}:9001"
    volumes:
      - "${MINIO_DATA_DIR}:/data"
      - "${MINIO_CERT_DIR}:/certs"
EOF
}

start_minio_compose() {
  local compose_cmd
  compose_cmd=$(get_compose_cmd) || exit 1

  mkdir -p "$MINIO_DATA_DIR"
  chown -R 1000:1000 "$MINIO_DATA_DIR"

  echo "Starting MinIO..."
  (cd "$MINIO_BASE_DIR" && $compose_cmd up -d)
}

wait_for_minio() {
  echo "Waiting for MinIO (HTTPS)..."
  local retries=60
  local health_url="https://${MINIO_FQDN}:${MINIO_S3_PORT}/minio/health/ready"

  for ((i=0; i<retries; i++)); do
    local code
    code=$(curl -k -s -o /dev/null -w "%{http_code}" "$health_url" || echo "000")

    if [[ "$code" == "200" ]]; then
      echo "MinIO is ready."
      return 0
    fi
    echo "  Retry $i/$retries (HTTP $code)..."
    sleep 5
  done
  echo "MinIO failed to start."
  exit 1
}

configure_minio_and_bucket() {
  echo "Configuring Bucket '$MINIO_DEFAULT_BUCKET' using image $MC_IMAGE..."
  local s3_url="https://${MINIO_FQDN}:${MINIO_S3_PORT}"
  
  # Clean up old mc container
  docker rm -f minio-mc >/dev/null 2>&1 || true

  docker run --rm \
    --network host \
    --name minio-mc \
    --entrypoint /bin/sh \
    "$MC_IMAGE" \
    -c "
      set -e
      mc --insecure alias set local '$s3_url' '$MINIO_ROOT_USER' '$MINIO_ROOT_PASSWORD'
      
      if ! mc --insecure ls local >/dev/null 2>&1; then
        echo 'ERROR: Connection failed.'
        exit 1
      fi

      if ! mc --insecure ls local/$MINIO_DEFAULT_BUCKET >/dev/null 2>&1; then
        mc --insecure mb local/$MINIO_DEFAULT_BUCKET --ignore-existing
        echo 'Bucket created.'
      else
        echo 'Bucket exists.'
      fi
    "
}

# --- Main Workflows --- #

install_minio() {
  # 1. Unpack if offline
  if [[ "$AIR_GAPPED_MODE" -eq 1 ]]; then
      echo "--- Air-Gapped Mode Detected ---"
      if [[ -f "minio-save.tar.gz" ]]; then
          tar -xzf minio-save.tar.gz
      fi
  fi

  debug_run install_docker
  debug_run validate_dns
  debug_run configure_registry_and_images
  debug_run generate_certs
  debug_run generate_compose_file
  debug_run start_minio_compose
  debug_run wait_for_minio
  debug_run configure_minio_and_bucket
  
  # Clean up extraction
  if [[ -d "$WORKING_DIR" ]]; then rm -rf "$WORKING_DIR"; fi

  echo
  echo "# --- MinIO Installation Completed --- #"
  echo "  Console: https://${MINIO_FQDN}:${MINIO_CONSOLE_PORT}"
  echo "  S3 API:  https://${MINIO_FQDN}:${MINIO_S3_PORT}"
  echo
}

uninstall_minio() {
  echo "Uninstalling MinIO..."
  stop_minio_compose
  rm -rf "$MINIO_BASE_DIR"
  docker rm -f minio-mc >/dev/null 2>&1 || true
  echo "MinIO removed."
}

usage() {
    cat << EOF
Usage: $0 [command] [options]

Commands:
  install-minio   : Install MinIO (Auto-detects online/offline)
  offline-prep    : Create 'minio-save.tar.gz' for air-gapped systems
  uninstall-minio : Remove MinIO

Options:
  -registry <url:port> <user> <pass>  : Push images to private registry
  
Examples:
  ./minio-installer.sh offline-prep
  ./minio-installer.sh install-minio
  ./minio-installer.sh install-minio -registry my.reg.com:5000 admin pass123
EOF
    exit 1
}

# --- Argument Parsing --- #

if [[ "$#" -eq 0 ]]; then usage; fi

while [[ "$#" -gt 0 ]]; do
    case "$1" in
        -h|--help) usage ;;
        install-minio)
            INSTALL_MODE=1
            shift
            ;;
        uninstall-minio)
            UNINSTALL_MODE=1
            shift
            ;;
        offline-prep)
            SAVE_MODE=1
            shift
            ;;
        -registry)
            REGISTRY_MODE=1
            REGISTRY_INFO="${2:-}"
            REG_USER="${3:-}"
            REG_PASS="${4:-}"
            if [[ -z "$REG_USER" || -z "$REG_PASS" ]]; then
                echo "Error: Registry requires url, username, password."
                exit 1
            fi
            # Parse FQDN/Port for variables
            REG_FQDN=$(echo "$REGISTRY_INFO" | cut -d':' -f1)
            REG_PORT=$(echo "$REGISTRY_INFO" | cut -d':' -f2)
            shift 4
            ;;
        *)
            echo "Invalid argument: $1"
            usage
            ;;
    esac
done

# --- Execution --- #

check_root_privileges
os_check

# Check for air-gap file
if [[ -f "minio-save.tar.gz" ]]; then AIR_GAPPED_MODE=1; fi

if [[ $SAVE_MODE -eq 1 ]]; then
    run_save
elif [[ $INSTALL_MODE -eq 1 ]]; then
    install_minio
elif [[ $UNINSTALL_MODE -eq 1 ]]; then
    uninstall_minio
fi