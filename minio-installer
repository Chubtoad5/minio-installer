#!/bin/bash
#
# MinIO single-node installer using Docker Compose
# Inspired by: install-harbor.sh framework
#

# --- User Defined Variables --- #

DEBUG=${DEBUG:-1}

# MinIO container version/tag
MINIO_VERSION=${MINIO_VERSION:-"latest"}        # e.g. "latest" or a specific release
MINIO_CLIENT_VERSION=${MINIO_CLIENT_VERSION:-"latest"}        # e.g. "latest" or a specific release

# Service identity / TLS
MINIO_FQDN=${MINIO_FQDN:-"minio.edge.lab"}
MINIO_WILDCARD_DOMAIN=${MINIO_WILDCARD_DOMAIN:-"*.edge.lab"}  # e.g. "*.example.com"

# Bind address for local host (for dual-homed systems, etc.)
BIND_ADDRESS=${BIND_ADDRESS:-"$(hostname -I | awk '{print $1}')"}  # IP to bind and use in SAN

# Certificate subject
COUNTRY=${COUNTRY:-"US"}
STATE=${STATE:-"MA"}
LOCATION=${LOCATION:-"BOSTON"}
ORGANIZATION=${ORGANIZATION:-"SELF"}
DURATION_DAYS=${DURATION_DAYS:-"3650"}

# MinIO admin credentials
MINIO_ROOT_USER=${MINIO_ROOT_USER:-"admin"}
MINIO_ROOT_PASSWORD=${MINIO_ROOT_PASSWORD:-"changeme"}

# Default bucket and bulk downloadconfig
MINIO_DEFAULT_BUCKET=${MINIO_DEFAULT_BUCKET:-"default-bucket"}
BULK_DOWNLOAD_URLS=${BULK_DOWNLOAD_URLS:-""} # space separated URLs, e.g. "https://example.com/path/to/file1.img https://example.com/path/to/file2.zip"

# Ports
MINIO_S3_PORT=${MINIO_S3_PORT:-"9000"}
MINIO_CONSOLE_PORT=${MINIO_CONSOLE_PORT:-"9001"}

# Paths
MINIO_BASE_DIR=${MINIO_BASE_DIR:-"/opt/minio"}
MINIO_DATA_DIR=${MINIO_DATA_DIR:-"$MINIO_BASE_DIR/data"}
MINIO_CERT_DIR=${MINIO_CERT_DIR:-"$MINIO_BASE_DIR/certs"}
MINIO_COMPOSE_FILE=${MINIO_COMPOSE_FILE:-"$MINIO_BASE_DIR/minio-compose.yml"}

# Container names
MINIO_CONTAINER_NAME=${MINIO_CONTAINER_NAME:-"minio-server"}

# --- INTERNAL VARIABLES (do not edit) --- #
AIR_GAPPED_MODE=0
SAVE_MODE=0
INSTALL_MODE=0
UNINSTALL_MODE=0
PUSH_MODE=0
REGISTRY_MODE=0
REGISTRY_INFO=""
REG_FQDN=""
REG_PORT=""
REG_USER=""
REG_PASS=""
fqdn_pattern='^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$'
ipv4_pattern='^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
base_dir=$(pwd)
user_name=${SUDO_USER:-$(whoami)}
mgmt_ip=$(hostname -I | awk '{print $1}')
current_hostname=$(hostname)

# --- Utility Functions --- #

debug_run() {
  if [ "$DEBUG" -eq 1 ]; then
    echo "--- DEBUG: Running '$*' ---"
    "$@"
    local status=$?
    echo "--- DEBUG: Finished '$*' with status $status ---"
    return $status
  else
    "$@" >/dev/null 2>&1
    return $?
  fi
}

check_root_privileges() {
  if [[ $EUID != 0 ]]; then
    echo "This script must be run with sudo or as the root user."
    exit 1
  fi
}

os_check () {
    # Get OS information from /etc/os-release
    if [[ -f /etc/os-release ]]; then
        # shellcheck disable=SC1091
        source /etc/os-release
        OS_ID_LIKE="${ID_LIKE:-}"
        OS_ID="${ID:-}"
    else
        echo "Unknown or unsupported OS $OS_ID."
        exit 1
    fi
    if [[ ! "$OS_ID" =~ ^(ubuntu|debian|rhel|centos|rocky|almalinux|fedora|sles|opensuse-leap)$ ]]; then
        echo "Unknown or unsupported OS $OS_ID."
        exit 1
    fi
}

image_pull_push_check () {
    if [[ ! -f $base_dir/utilities/image_pull_push.sh ]]; then
        echo "  Downloading image_pull_push.sh..."
        curl -sfL https://github.com/Chubtoad5/images-pull-push/raw/refs/heads/main/image_pull_push.sh  -o $base_dir/utilities/image_pull_push.sh
        chmod +x $base_dir/utilities/image_pull_push.sh
    fi
}


run_docker() {
  echo "  Verifying Docker Config..."
  if [[ $AIR_GAPPED_MODE -eq 0 ]]; then
    image_pull_push_check
    if [[ $PUSH_MODE -eq 1 ]]; then
      cat >$base_dir/utilities/images.txt <<EOF
minio/minio:${MINIO_VERSION}
minio/mc:${MINIO_CLIENT_VERSION}
EOF
      $base_dir/utilities/image_pull_push.sh -f $base_dir/utilities/images.txt push $REGISTRY_INFO $REG_USER $REG_PASS
    else
      $base_dir/utilities/image_pull_push.sh docker
      # Still grab registry cert if needed
      if [[ $REGISTRY_MODE -eq 1 ]]; then
        $base_dir/utilities/image_pull_push.sh reg-cert $REGISTRY_INFO
      fi
    fi
  else
    # AIR_GAPPED_MODE is set
    for file in "$base_dir/utilities/container_images_*.tar.gz"; do
      if [[ $PUSH_MODE -eq 1 ]]; then
        $base_dir/utilities/image_pull_push.sh -f $file push $REGISTRY_INFO $REG_USER $REG_PASS
      else
        $base_dir/utilities/image_pull_push.sh -f $file keep
      fi
    done
    # Still grab registry cert if needed
    if [[ $REGISTRY_MODE -eq 1 ]]; then
      $base_dir/utilities/image_pull_push.sh reg-cert $REGISTRY_INFO
    fi
  fi
}

validate_dns() {
  echo "  Validating DNS for '$MINIO_FQDN' against bind address '$BIND_ADDRESS'..."
  local dns_ip
  dns_ip=$(getent ahosts "$MINIO_FQDN" 2>/dev/null | awk '/STREAM/ {print $1; exit}')

  if [[ -z "$dns_ip" ]]; then
    echo "  WARNING: DNS lookup for '$MINIO_FQDN' failed. The name may not be resolvable."
    return 0
  fi

  if [[ "$dns_ip" != "$BIND_ADDRESS" ]]; then
    echo "  WARNING: DNS for '$MINIO_FQDN' resolves to '$dns_ip' but bind address is '$BIND_ADDRESS'."
    echo "  Clients may not be able to reach MinIO using the configured FQDN."
  else
    echo "  DNS validation successful: '$MINIO_FQDN' -> '$dns_ip'."
  fi
}

display_args() {
    echo "### MinIO Installer Started $(date) ###"
    echo "  AIR_GAPPED_MODE: $AIR_GAPPED_MODE"
    echo "  INSTALL_MODE: $INSTALL_MODE"
    echo "  UNINSTALL_MODE: $UNINSTALL_MODE"
    echo "  DEBUG: $DEBUG"
    echo "  PUSH_MODE: $PUSH_MODE"
    echo "  SAVE_MODE: $SAVE_MODE"
    echo "  REGISTRY_MODE: $REGISTRY_MODE"
    echo "  REGISTRY_INFO: $REGISTRY_INFO"
    echo "  REG_FQDN: $REG_FQDN"
    echo "  REG_PORT: $REG_PORT"
    echo "  REG_USER: $REG_USER"
    echo "  REG_PASS: $REG_PASS"
    echo "  OS: $OS_ID"
}

# --- TLS Certificate Generation --- #

generate_certs() {
  echo "  Creating self-signed certificate valid for $DURATION_DAYS days..."
  mkdir -p "$MINIO_CERT_DIR/CAs"
  mkdir -p "$base_dir/tmp_certs"

  # CA key + cert (for completeness, MinIO uses public/private only)
  openssl genrsa -out "$base_dir/tmp_certs/ca.key" 4096
  openssl req -x509 -new -nodes -sha512 -days "$DURATION_DAYS" \
    -subj "/C=$COUNTRY/ST=$STATE/L=$LOCATION/O=$ORGANIZATION/CN=$MINIO_WILDCARD_DOMAIN" \
    -key "$base_dir/tmp_certs/ca.key" \
    -out "$base_dir/tmp_certs/ca.crt"

  # Server key
  openssl genrsa -out "$base_dir/tmp_certs/private.key" 4096

  # CSR
  openssl req -sha512 -new \
    -subj "/C=$COUNTRY/ST=$STATE/L=$LOCATION/O=$ORGANIZATION/CN=$MINIO_WILDCARD_DOMAIN" \
    -key "$base_dir/tmp_certs/private.key" \
    -out "$base_dir/tmp_certs/minio.csr"

  # v3.ext for SANs
  cat >"$base_dir/tmp_certs/v3.ext" <<EOF
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names

[alt_names]
DNS.1 = $MINIO_WILDCARD_DOMAIN
DNS.2 = $MINIO_FQDN
DNS.3 = $current_hostname
IP.1  = $BIND_ADDRESS
EOF

  # Signed cert -> public.crt (MinIO requires /certs/public.crt and /certs/private.key)
  openssl x509 -req -sha512 -days "$DURATION_DAYS" \
    -extfile "$base_dir/tmp_certs/v3.ext" \
    -CA "$base_dir/tmp_certs/ca.crt" \
    -CAkey "$base_dir/tmp_certs/ca.key" \
    -CAcreateserial \
    -in "$base_dir/tmp_certs/minio.csr" \
    -out "$base_dir/tmp_certs/public.crt"

  # Move certs to final location
  cp "$base_dir/tmp_certs/public.crt" "$MINIO_CERT_DIR/public.crt"
  cp "$base_dir/tmp_certs/private.key" "$MINIO_CERT_DIR/private.key"
  cp "$base_dir/tmp_certs/ca.crt" "$MINIO_CERT_DIR/CAs/ca.crt"
  chown -R 1000:1000 "$MINIO_CERT_DIR"

  echo "  Certificate generation completed."
}

# --- Docker Compose Configuration --- #

generate_compose_file() {
  echo "  Generating minio-compose.yml at $MINIO_COMPOSE_FILE ..."
  mkdir -p "$MINIO_BASE_DIR"
  if [[ $REGISTRY_MODE -eq 1 ]]; then
    local image="${REG_FQDN}:${REG_PORT}/minio/minio:${MINIO_VERSION}"
  else
    local image="minio/minio:${MINIO_VERSION}"
  fi

  cat >"$MINIO_COMPOSE_FILE" <<EOF
services:
  minio:
    image: $image
    container_name: ${MINIO_CONTAINER_NAME}
    hostname: ${current_hostname}
    restart: unless-stopped
    command: server /data --console-address ":9001" --certs-dir /certs
    environment:
      MINIO_ROOT_USER: "${MINIO_ROOT_USER}"
      MINIO_ROOT_PASSWORD: "${MINIO_ROOT_PASSWORD}"
      MINIO_SERVER_URL: "https://${MINIO_FQDN}:${MINIO_S3_PORT}"
      MINIO_BROWSER_REDIRECT_URL: "https://${MINIO_FQDN}:${MINIO_CONSOLE_PORT}"
    ports:
      - "${BIND_ADDRESS}:${MINIO_S3_PORT}:9000"
      - "${BIND_ADDRESS}:${MINIO_CONSOLE_PORT}:9001"
    volumes:
      - "${MINIO_DATA_DIR}:/data"
      - "${MINIO_CERT_DIR}:/certs"
EOF
}

start_minio_compose() {
  mkdir -p "$MINIO_DATA_DIR"
  chown -R 1000:1000 "$MINIO_DATA_DIR"

  if [[ -d "$MINIO_DATA_DIR/.minio.sys" ]]; then
    echo "  NOTE: Existing MinIO data directory detected at '$MINIO_DATA_DIR'."
    echo "        Existing credentials/config will be preserved. New MINIO_ROOT_USER/PASSWORD may be ignored."
  fi

  echo "  Starting MinIO using Docker Compose..."
  (docker compose -f "$MINIO_COMPOSE_FILE" up -d)
}

stop_minio_compose() {
  if [[ -f "$MINIO_COMPOSE_FILE" ]]; then
    echo "  Stopping MinIO using Docker Compose..."
    (docker compose -f "$MINIO_COMPOSE_FILE" down || true)
  fi
}

# --- Health Check --- #

wait_for_minio() {
  echo "  Waiting for MinIO to become ready (HTTPS)..."
  local retries=60
  local delay=5
  local i=0

  # Health endpoint: /minio/health/ready on S3 port
  local health_url="https://${MINIO_FQDN}:${MINIO_S3_PORT}/minio/health/ready"

  while ((i < retries)); do
    local code
    code=$(curl -k -s -o /dev/null -w "%{http_code}" "$health_url" || echo "000")

    if [[ "$code" == "200" ]]; then
      echo "  MinIO reports ready (HTTP $code)."
      return 0
    fi

    i=$((i + 1))
    echo "  Attempt $i/$retries: MinIO not ready yet (HTTP $code), retrying in ${delay}s..."
    sleep "$delay"
  done

  echo "  WARNING: MinIO did not become healthy within the expected time. mc operations may fail."
}

# --- MinIO Client (mc) and Bucket Creation --- #

configure_minio_and_bucket() {
  echo "  Configuring MinIO with default bucket '$MINIO_DEFAULT_BUCKET'..."
  local s3_url="https://${MINIO_FQDN}:${MINIO_S3_PORT}"
  if [[ $REGISTRY_MODE -eq 1 ]]; then
    local image="${REG_FQDN}:${REG_PORT}/minio/mc:${MINIO_CLIENT_VERSION}"
  else
    local image="minio/mc:${MINIO_CLIENT_VERSION}"
  fi

  # Remove any stale mc container
  if docker ps -a --format '{{.Names}}' | grep -q "^minio-mc\$"; then
    docker rm -f minio-mc >/dev/null 2>&1 || true
  fi

  # FIX: Added --network host so the container shares the host's DNS and IP visibility
  docker run --rm \
    --network host \
    --name minio-mc \
    --entrypoint /bin/sh \
    $image \
    -c "
      set -e

      # Attempt to set alias (removed >/dev/null to allow visibility on error)
      echo '  Setting mc alias...'
      mc --insecure alias set local '$s3_url' '$MINIO_ROOT_USER' '$MINIO_ROOT_PASSWORD'

      if ! mc --insecure ls local >/dev/null 2>&1; then
        echo '  ERROR: Failed to connect to MinIO using mc.'
        exit 1
      fi

      echo '  Ensuring bucket exists...'
      if ! mc --insecure ls local/$MINIO_DEFAULT_BUCKET >/dev/null 2>&1; then
        mc --insecure mb local/$MINIO_DEFAULT_BUCKET --ignore-existing
      else
        echo '  Bucket already exists.'
      fi
    "

  # Check exit code of the docker run command to confirm success
  if [ $? -eq 0 ]; then
      echo "  Default bucket '${MINIO_DEFAULT_BUCKET}' created."
  else
      echo "  ERROR: Failed to configure MinIO bucket."
      exit 1
  fi
}

bulk_download () {
  mkdir -p "$base_dir/upload" || true
  # checks for files to download locally then upload to S3 bucket
  [[ $AIR_GAPPED_MODE -eq 0 ]] || return 0
  echo "  Checking for bulk file download..."
  read -a BULK_DOWNLOAD_ARRAY <<< "$BULK_DOWNLOAD_URLS"
  if [[ -z "${BULK_DOWNLOAD_ARRAY[*]}" ]]; then
      echo "  No bulk file download URLs provided, skipping."
      return 0
  else
    for file in "${BULK_DOWNLOAD_ARRAY[@]}"; do
      echo "  Downloading: $(basename "$file")"
      curl -ksfL "$file" -o "$base_dir/upload/$(basename "$file")"
    done
  fi
}

bulk_upload() {
    local source_dir="$1"
    local target_bucket="${2:-default-bucket}" # Defaults to 'default-bucket'
    
    if [[ ! -d "$source_dir" ]]; then
        echo "  Directory '$source_dir' not found, skipping bulk upload."
        return 0
    fi
    if [[ -z "ls -A $source_dir" ]]; then
        echo "  Directory '$source_dir' is empty, skipping bulk upload."
        return 0
    fi
    echo "  Starting bulk upload from '$source_dir' to bucket '$target_bucket'..."
    docker run --rm \
        --network host \
        --entrypoint /bin/sh \
        -v "$(realpath "$source_dir"):/upload" \
        -e MINIO_ROOT_USER="$MINIO_ROOT_USER" \
        -e MINIO_ROOT_PASSWORD="$MINIO_ROOT_PASSWORD" \
        minio/mc \
        -c "
            # Set alias using internal quotes to protect passwords with special chars
            mc --insecure alias set local https://${MINIO_FQDN}:${MINIO_S3_PORT} \"\$MINIO_ROOT_USER\" \"\$MINIO_ROOT_PASSWORD\" > /dev/null;
            echo '  Starting synchronization...'
            # Use mirror for performance; trailing slash on /upload/ copies CONTENTS, not the folder
            mc --insecure mirror --quiet /upload/ \"local/$target_bucket/\"
        "
}

# --- Routines --- #

install_minio() {
  debug_run run_docker
  debug_run validate_dns
  debug_run generate_certs
  debug_run generate_compose_file
  debug_run start_minio_compose
  debug_run wait_for_minio
  debug_run configure_minio_and_bucket
  debug_run bulk_download
  debug_run bulk_upload "$base_dir/upload" "$MINIO_DEFAULT_BUCKET"

  local console_url="https://${MINIO_FQDN}:${MINIO_CONSOLE_PORT}"
  local s3_url="https://${MINIO_FQDN}:${MINIO_S3_PORT}/${MINIO_DEFAULT_BUCKET}"

  echo
  echo "# --- MinIO Installation Completed --- #"
  echo "  MinIO Image:           minio/minio:${MINIO_VERSION}"
  echo "  Bind Address:          $BIND_ADDRESS"
  echo "  FQDN:                  $MINIO_FQDN"
  echo "  Data Directory:        $MINIO_DATA_DIR"
  echo
  echo "  Console URL:           $console_url"
  echo "  S3 Endpoint URL:       $s3_url"
  echo
  echo "  Admin User:            $MINIO_ROOT_USER"
  echo "  Admin Password:        $MINIO_ROOT_PASSWORD"
  echo
  echo "  Default Bucket:        $MINIO_DEFAULT_BUCKET"
  echo
}

run_save () {
  echo "  Preparing MinIO offline archive..."
  debug_run image_pull_push_check
  cat >$base_dir/utilities/images.txt <<EOF
minio/minio:${MINIO_VERSION}
minio/mc:${MINIO_CLIENT_VERSION}
EOF
  cd $base_dir/utilities
  debug_run ./image_pull_push.sh -f $base_dir/utilities/images.txt save
  cd $base_dir
  debug_run bulk_download
  tar czf $base_dir/minio-save.tar.gz utilities minio-installer upload
  echo "  created 'minio-save.tar.gz' for air-gapped deployment."
}

uninstall_minio() {
  echo "  Uninstalling MinIO..."

  debug_run stop_minio_compose

  # Remove remaining container if still present
  if docker ps -a --format '{{.Names}}' | grep -q "^${MINIO_CONTAINER_NAME}\$"; then
    echo "  Removing MinIO container '$MINIO_CONTAINER_NAME'..."
    docker rm -f "$MINIO_CONTAINER_NAME" >/dev/null 2>&1 || true
  fi

  echo "  Removing MinIO directories under '$MINIO_BASE_DIR'..."
  rm -rf "$MINIO_BASE_DIR" || true
  echo "  Removing tmp_certs and utilities directories..."
  rm -rf "$base_dir/tmp_certs" "$base_dir/utilities" "$base_dir/upload" || true
  echo "  MinIO uninstallation completed."
}

# --- CLI Help --- #

help() {
  cat <<EOF
Usage: $0 [command] [option]

Commands:
  help              | Display this help message
  install           | Install and configure MinIO (Docker Compose)
  save              | Prepare offline archive for air-gapped deployment
  uninstall         | Uninstall MinIO and remove data/config

Options:
  push              | Push MinIO images to a local registry, must include -registry option
  -registry         | Registry credentials for pushing or pulling from local registry (Format: -registry [registry:port username password])

Examples:
  $0 install
  $0 save
  $0 uninstall
  $0 install -registry myregistry:5000 user password
  $0 install push -registry myregistry:5000 user password
EOF
  exit 1
}

# --- CLI Wrapper --- #
if [[ "$#" -eq 0 ]]; then
    echo "Error: No arguments provided."
    help
fi

while [[ $# -gt 0 ]]; do
  case "$1" in
    help|--help|-h) help ;;
    install)
      INSTALL_MODE=1
      ;;
    save)
      SAVE_MODE=1
      ;;
    push)
      PUSH_MODE=1
      ;;
    uninstall)
      UNINSTALL_MODE=1
      ;;
    -registry)
      REGISTRY_MODE=1
      REGISTRY_INFO="${2:-}"
      REG_USER="${3:-}"
      REG_PASS="${4:-}"
      if [[ -z "$REG_USER" || -z "$REG_PASS" ]]; then
          echo "Error: Registry info requires a username and password. Format: -registry [registry:port username password]"
          echo "Use '--help' for usage."
          exit 1
      fi
      shift 3
      ;;
    *)
      echo "Invalid argument: $1"
      echo
      ;;
  esac
  shift
done

check_root_privileges
os_check

# -- Argument Validation -- #
if [[ $INSTALL_MODE -eq 1 ]]; then 
  if [[ $UNINSTALL_MODE -eq 1 || $SAVE_MODE -eq 1 ]]; then 
    echo "Error: install, offline-prep, or uninstall cannot be used together."; exit 1; fi
fi
if [[ $UNINSTALL_MODE -eq 1 ]]; then 
  if [[ $INSTALL_MODE -eq 1 || $SAVE_MODE -eq 1 ]]; then 
    echo "Error: install, offline-prep, or uninstall cannot be used together.";exit 1; fi
  if [[ $PUSH_MODE -eq 1 || $REGISTRY_MODE -eq 1 ]]; then
    echo "Error: push or registry cannot be used with uninstall."; exit 1; fi
fi
if [[ $SAVE_MODE -eq 1 ]]; then 
  if [[ $INSTALL_MODE -eq 1 || $UNINSTALL_MODE -eq 1 ]]; then 
    echo "Error: install, offline-prep, or uninstall cannot be used together."; exit 1; fi
  if [[ $PUSH_MODE -eq 1 || $REGISTRY_MODE -eq 1 ]]; then
    echo "Error: push or registry cannot be used with save."; exit 1; fi
fi
if [[ $PUSH_MODE -eq 1 ]]; then 
  if [[ $SAVE_MODE -eq 1 || $UNINSTALL_MODE -eq 1 ]]; then
    echo "Error: save or uninstall cannot be used with push."; exit 1; fi
fi
if [[ "$REGISTRY_MODE" == "1" ]]; then
    if [[ "$REGISTRY_INFO" =~ ^https?:// ]]; then
        echo "Error: registry info must be a valid FQDN or IPv4 format. i.e. 'my.regsitry.com:443'."
        exit 1
    fi
    REG_FQDN=$(echo "$REGISTRY_INFO" | cut -d':' -f1)
    REG_PORT=$(echo "$REGISTRY_INFO" | cut -d':' -f2)
    if [[ ! ( "$REG_FQDN" =~ $fqdn_pattern || "$REG_FQDN" =~ $ipv4_pattern ) ]]; then
        echo "Error: Registry url must be a valid FQDN or IPv4 format. i.e. 'my.regsitry.com' or '192.168.1.50'."
        exit 1
    fi
    if [[ "$REG_PORT" =~ ^[0-9]+$ ]]; then
        if [[ "$REG_PORT" -lt 1 || "$REG_PORT" -gt 65535 ]]; then
            echo "Error: Registry port must be a number between 1 and 65535."
            exit 1
        fi
    else
        echo "Error: Registry port must be a number between 1 and 65535."
        exit 1
    fi
fi
[[ ! -f $base_dir/minio-save.tar.gz ]] || AIR_GAPPED_MODE=1

# -- Main Logic -- #

echo "### MinIO Installer Started - $(date) ###"
display_args

if [[ $AIR_GAPPED_MODE -eq 1 ]]; then
  echo "  Extracting minio-save.tar.gz"
  tar -xzf $base_dir/minio-save.tar.gz
fi
[[ -d $base_dir/utilities ]] || mkdir -p $base_dir/utilities
if [[ $INSTALL_MODE -eq 1 ]]; then
  echo "### MinIO Installation Starting ###"
  install_minio
fi
if [[ $SAVE_MODE -eq 1 ]]; then
  echo "### MinIO Save Starting ###"
  run_save
fi
if [[ $UNINSTALL_MODE -eq 1 ]]; then 
  echo "### MinIO Uninstallation Starting ###"
  uninstall_minio
fi
echo "### MinIO Installer Finished - $(date) ###"

