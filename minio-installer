#!/bin/bash
#
# MinIO single-node installer using Docker Compose
# Inspired by: install-harbor.sh framework
#

# --- User Defined Variables --- #

DEBUG=${DEBUG:-1}

# MinIO container version/tag
MINIO_VERSION=${MINIO_VERSION:-"latest"}        # e.g. "latest" or a specific release
MINIO_CLIENT_VERSION=${MINIO_CLIENT_VERSION:-"latest"}        # e.g. "latest" or a specific release

# Service identity / TLS
MINIO_FQDN=${MINIO_FQDN:-"minio.edge.lab"}
MINIO_WILDCARD_DOMAIN=${MINIO_WILDCARD_DOMAIN:-"*.edge.lab"}  # e.g. "*.example.com"

# Bind address for local host (for dual-homed systems, etc.)
BIND_ADDRESS=${BIND_ADDRESS:-"$(hostname -I | awk '{print $1}')"}  # IP to bind and use in SAN

# Certificate subject
COUNTRY=${COUNTRY:-"US"}
STATE=${STATE:-"MA"}
LOCATION=${LOCATION:-"BOSTON"}
ORGANIZATION=${ORGANIZATION:-"SELF"}
DURATION_DAYS=${DURATION_DAYS:-"3650"}

# MinIO admin credentials
MINIO_ROOT_USER=${MINIO_ROOT_USER:-"minioadmin"}
MINIO_ROOT_PASSWORD=${MINIO_ROOT_PASSWORD:-"minioadmin123"}

# Default bucket config
MINIO_DEFAULT_BUCKET=${MINIO_DEFAULT_BUCKET:-"default-bucket"}

# Ports
MINIO_S3_PORT=${MINIO_S3_PORT:-"9000"}
MINIO_CONSOLE_PORT=${MINIO_CONSOLE_PORT:-"9001"}

# Paths
MINIO_BASE_DIR=${MINIO_BASE_DIR:-"/opt/minio"}
MINIO_DATA_DIR=${MINIO_DATA_DIR:-"$MINIO_BASE_DIR/data"}
MINIO_CERT_DIR=${MINIO_CERT_DIR:-"$MINIO_BASE_DIR/certs"}
MINIO_COMPOSE_FILE=${MINIO_COMPOSE_FILE:-"$MINIO_BASE_DIR/docker-compose.yml"}

# Container names
MINIO_CONTAINER_NAME=${MINIO_CONTAINER_NAME:-"minio-server"}

# --- INTERNAL VARIABLES (do not edit) --- #
AIR_GAPPED_MODE=0
SAVE_MODE=0
INSTALL_MODE=0
UNINSTALL_MODE=0
REGISTRY_MODE=0
REGISTRY_INFO=""
REG_FQDN=""
REG_PORT=""
REG_USER=""
REG_PASS=""
fqdn_pattern='^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$'
ipv4_pattern='^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
base_dir=$(pwd)
user_name=${SUDO_USER:-$(whoami)}
mgmt_ip=$(hostname -I | awk '{print $1}')
current_hostname=$(hostname)

# --- Utility Functions --- #

debug_run() {
  if [ "$DEBUG" -eq 1 ]; then
    echo "--- DEBUG: Running '$*' ---"
    "$@"
    local status=$?
    echo "--- DEBUG: Finished '$*' with status $status ---"
    return $status
  else
    "$@" >/dev/null 2>&1
    return $?
  fi
}

check_root_privileges() {
  if [[ $EUID != 0 ]]; then
    echo "This script must be run with sudo or as the root user."
    exit 1
  fi
}

os_check () {
    # Get OS information from /etc/os-release
    if [[ -f /etc/os-release ]]; then
        # shellcheck disable=SC1091
        source /etc/os-release
        OS_ID_LIKE="${ID_LIKE:-}"
        OS_ID="${ID:-}"
    else
        echo "Unknown or unsupported OS $OS_ID."
        exit 1
    fi
    if [[ ! "$OS_ID" =~ ^(ubuntu|debian|rhel|centos|rocky|almalinux|fedora|sles|opensuse-leap)$ ]]; then
        echo "Unknown or unsupported OS $OS_ID."
        exit 1
    fi
}

check_docker_installed() {
  if ! command -v docker >/dev/null 2>&1; then
    echo "Error: docker is not installed or not in PATH."
    echo "Please install Docker before running this script."
    exit 1
  fi
}

get_compose_cmd() {
  if docker compose version >/dev/null 2>&1; then
    echo "docker compose"
  elif command -v docker-compose >/dev/null 2>&1; then
    echo "docker-compose"
  else
    echo "Error: docker compose (plugin) or docker-compose (standalone) is required." >&2
    return 1
  fi
}

validate_dns() {
  echo "Validating DNS for '$MINIO_FQDN' against bind address '$BIND_ADDRESS'..."
  local dns_ip
  dns_ip=$(getent ahosts "$MINIO_FQDN" 2>/dev/null | awk '/STREAM/ {print $1; exit}')

  if [[ -z "$dns_ip" ]]; then
    echo "WARNING: DNS lookup for '$MINIO_FQDN' failed. The name may not be resolvable."
    return 0
  fi

  if [[ "$dns_ip" != "$BIND_ADDRESS" ]]; then
    echo "WARNING: DNS for '$MINIO_FQDN' resolves to '$dns_ip' but bind address is '$BIND_ADDRESS'."
    echo "Clients may not be able to reach MinIO using the configured FQDN."
  else
    echo "DNS validation successful: '$MINIO_FQDN' -> '$dns_ip'."
  fi
}

display_args() {
    echo "### MinIO Installer Started $(date) ###"
    echo "  AIR_GAPPED_MODE: $AIR_GAPPED_MODE"
    echo "  INSTALL_MODE: $INSTALL_MODE"
    echo "  UNINSTALL_MODE: $UNINSTALL_MODE"
    echo "  SAVE_MODE: $SAVE_MODE"
    echo "  REGISTRY_MODE: $REGISTRY_MODE"
    echo "  REGISTRY_INFO: $REGISTRY_INFO"
    echo "  REG_FQDN: $REG_FQDN"
    echo "  REG_PORT: $REG_PORT"
    echo "  REG_USER: $REG_USER"
    echo "  REG_PASS: $REG_PASS"
    echo "  OS: $OS_ID"
}

# --- TLS Certificate Generation --- #

generate_certs() {
  echo "Creating self-signed certificate valid for $DURATION_DAYS days..."
  mkdir -p "$MINIO_CERT_DIR/CAs"
  mkdir -p "$base_dir/tmp_certs"

  # CA key + cert (for completeness, MinIO uses public/private only)
  openssl genrsa -out "$base_dir/tmp_certs/ca.key" 4096
  openssl req -x509 -new -nodes -sha512 -days "$DURATION_DAYS" \
    -subj "/C=$COUNTRY/ST=$STATE/L=$LOCATION/O=$ORGANIZATION/CN=$MINIO_WILDCARD_DOMAIN" \
    -key "$base_dir/tmp_certs/ca.key" \
    -out "$base_dir/tmp_certs/ca.crt"

  # Server key
  openssl genrsa -out "$base_dir/tmp_certs/private.key" 4096

  # CSR
  openssl req -sha512 -new \
    -subj "/C=$COUNTRY/ST=$STATE/L=$LOCATION/O=$ORGANIZATION/CN=$MINIO_WILDCARD_DOMAIN" \
    -key "$base_dir/tmp_certs/private.key" \
    -out "$base_dir/tmp_certs/minio.csr"

  # v3.ext for SANs
  cat >"$base_dir/tmp_certs/v3.ext" <<EOF
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names

[alt_names]
DNS.1 = $MINIO_WILDCARD_DOMAIN
DNS.2 = $MINIO_FQDN
DNS.3 = $current_hostname
IP.1  = $BIND_ADDRESS
EOF

  # Signed cert -> public.crt (MinIO requires /certs/public.crt and /certs/private.key)
  openssl x509 -req -sha512 -days "$DURATION_DAYS" \
    -extfile "$base_dir/tmp_certs/v3.ext" \
    -CA "$base_dir/tmp_certs/ca.crt" \
    -CAkey "$base_dir/tmp_certs/ca.key" \
    -CAcreateserial \
    -in "$base_dir/tmp_certs/minio.csr" \
    -out "$base_dir/tmp_certs/public.crt"

  # Move certs to final location
  cp "$base_dir/tmp_certs/public.crt" "$MINIO_CERT_DIR/public.crt"
  cp "$base_dir/tmp_certs/private.key" "$MINIO_CERT_DIR/private.key"
  cp "$base_dir/tmp_certs/ca.crt" "$MINIO_CERT_DIR/CAs/ca.crt"
  chown -R 1000:1000 "$MINIO_CERT_DIR"

  echo "Certificate generation completed."
}

# --- Docker Compose Configuration --- #

generate_compose_file() {
  echo "Generating docker-compose.yml at $MINIO_COMPOSE_FILE ..."
  mkdir -p "$MINIO_BASE_DIR"

  cat >"$MINIO_COMPOSE_FILE" <<EOF
services:
  minio:
    image: minio/minio:${MINIO_VERSION}
    container_name: ${MINIO_CONTAINER_NAME}
    hostname: ${current_hostname}
    restart: unless-stopped
    command: server /data --console-address ":9001" --certs-dir /certs
    environment:
      MINIO_ROOT_USER: "${MINIO_ROOT_USER}"
      MINIO_ROOT_PASSWORD: "${MINIO_ROOT_PASSWORD}"
      MINIO_SERVER_URL: "https://${MINIO_FQDN}:${MINIO_S3_PORT}"
      MINIO_BROWSER_REDIRECT_URL: "https://${MINIO_FQDN}:${MINIO_CONSOLE_PORT}"
    ports:
      - "${BIND_ADDRESS}:${MINIO_S3_PORT}:9000"
      - "${BIND_ADDRESS}:${MINIO_CONSOLE_PORT}:9001"
    volumes:
      - "${MINIO_DATA_DIR}:/data"
      - "${MINIO_CERT_DIR}:/certs"
EOF
}

start_minio_compose() {
  local compose_cmd
  compose_cmd=$(get_compose_cmd) || exit 1

  mkdir -p "$MINIO_DATA_DIR"
  chown -R 1000:1000 "$MINIO_DATA_DIR"

  if [[ -d "$MINIO_DATA_DIR/.minio.sys" ]]; then
    echo "NOTE: Existing MinIO data directory detected at '$MINIO_DATA_DIR'."
    echo "      Existing credentials/config will be preserved. New MINIO_ROOT_USER/PASSWORD may be ignored."
  fi

  echo "Starting MinIO using Docker Compose..."
  (cd "$MINIO_BASE_DIR" && $compose_cmd up -d)
}

stop_minio_compose() {
  local compose_cmd
  compose_cmd=$(get_compose_cmd) || return 0

  if [[ -f "$MINIO_COMPOSE_FILE" ]]; then
    echo "Stopping MinIO using Docker Compose..."
    (cd "$MINIO_BASE_DIR" && $compose_cmd down || true)
  fi
}

# --- Health Check --- #

wait_for_minio() {
  echo "Waiting for MinIO to become ready (HTTPS)..."
  local retries=60
  local delay=5
  local i=0

  # Health endpoint: /minio/health/ready on S3 port
  local health_url="https://${MINIO_FQDN}:${MINIO_S3_PORT}/minio/health/ready"

  while ((i < retries)); do
    local code
    code=$(curl -k -s -o /dev/null -w "%{http_code}" "$health_url" || echo "000")

    if [[ "$code" == "200" ]]; then
      echo "MinIO reports ready (HTTP $code)."
      return 0
    fi

    i=$((i + 1))
    echo "  Attempt $i/$retries: MinIO not ready yet (HTTP $code), retrying in ${delay}s..."
    sleep "$delay"
  done

  echo "WARNING: MinIO did not become healthy within the expected time. mc operations may fail."
}

# --- MinIO Client (mc) and Bucket Creation --- #

configure_minio_and_bucket() {
  echo "Configuring MinIO with default bucket '$MINIO_DEFAULT_BUCKET'..."
  local s3_url="https://${MINIO_FQDN}:${MINIO_S3_PORT}"

  # Remove any stale mc container
  if docker ps -a --format '{{.Names}}' | grep -q "^minio-mc\$"; then
    docker rm -f minio-mc >/dev/null 2>&1 || true
  fi

  # FIX: Added --network host so the container shares the host's DNS and IP visibility
  docker run --rm \
    --network host \
    --name minio-mc \
    --entrypoint /bin/sh \
    minio/mc:${MINIO_CLIENT_VERSION} \
    -c "
      set -e

      # Attempt to set alias (removed >/dev/null to allow visibility on error)
      echo 'Setting mc alias...'
      mc --insecure alias set local '$s3_url' '$MINIO_ROOT_USER' '$MINIO_ROOT_PASSWORD'

      if ! mc --insecure ls local >/dev/null 2>&1; then
        echo 'ERROR: Failed to connect to MinIO using mc.'
        exit 1
      fi

      echo 'Ensuring bucket exists...'
      if ! mc --insecure ls local/$MINIO_DEFAULT_BUCKET >/dev/null 2>&1; then
        mc --insecure mb local/$MINIO_DEFAULT_BUCKET --ignore-existing
      else
        echo 'Bucket already exists.'
      fi
    "

  # Check exit code of the docker run command to confirm success
  if [ $? -eq 0 ]; then
      echo "Default bucket '${MINIO_DEFAULT_BUCKET}' created."
  else
      echo "ERROR: Failed to configure MinIO bucket."
      exit 1
  fi
}

# --- Routines --- #

install_minio() {
  debug_run check_docker_installed
  debug_run validate_dns
  debug_run generate_certs
  debug_run generate_compose_file
  debug_run start_minio_compose
  debug_run wait_for_minio
  debug_run configure_minio_and_bucket

  local console_url="https://${MINIO_FQDN}:${MINIO_CONSOLE_PORT}"
  local s3_url="https://${MINIO_FQDN}:${MINIO_S3_PORT}/${MINIO_DEFAULT_BUCKET}"

  echo
  echo "# --- MinIO Installation Completed --- #"
  echo "  MinIO Image:           minio/minio:${MINIO_VERSION}"
  echo "  Bind Address:          $BIND_ADDRESS"
  echo "  FQDN:                  $MINIO_FQDN"
  echo "  Data Directory:        $MINIO_DATA_DIR"
  echo "  Certificates Directory:$MINIO_CERT_DIR"
  echo "  Compose File:          $MINIO_COMPOSE_FILE"
  echo
  echo "  Console URL:           $console_url"
  echo "  S3 Endpoint URL:       $s3_url"
  echo
  echo "  Admin User:            $MINIO_ROOT_USER"
  echo "  Admin Password:        $MINIO_ROOT_PASSWORD"
  echo
  echo "  Default Bucket:        $MINIO_DEFAULT_BUCKET"
  echo
}

offline_prep () {
  echo "  Preparing MinIO offline archive..."
}

uninstall_minio() {
  echo "Uninstalling MinIO..."

  stop_minio_compose

  # Remove remaining container if still present
  if docker ps -a --format '{{.Names}}' | grep -q "^${MINIO_CONTAINER_NAME}\$"; then
    echo "Removing MinIO container '$MINIO_CONTAINER_NAME'..."
    docker rm -f "$MINIO_CONTAINER_NAME" >/dev/null 2>&1 || true
  fi

  echo "Removing MinIO directories under '$MINIO_BASE_DIR'..."
  rm -rf "$MINIO_BASE_DIR"

  echo "MinIO uninstallation completed."
}

# --- CLI Help --- #

help() {
  cat <<EOF
Usage: $0 [command] [option]

Commands:
  help              | Display this help message
  install           | Install and configure MinIO (Docker Compose)
  save              | Prepare offline archive for air-gapped deployment
  uninstall         | Uninstall MinIO and remove data/config

Options:
  -registry [url:port] [user] [password] | Push images to a local registry
EOF
  exit 1
}

# --- CLI Wrapper --- #
if [[ "$#" -eq 0 ]]; then
    echo "Error: No arguments provided."
    help
fi

while [[ $# -gt 0 ]]; do
  case "$1" in
    help|--help|-h) help ;;
    install)
      INSTALL_MODE=1
      shift
      ;;
    save)
      SAVE_MODE=1
      shift
      ;;
    push)
      PUSH_MODE=1
      shift
      ;;
    uninstall)
      UNINSTALL_MODE=1
      shift
      ;;
    -registry)
      REGISTRY_MODE=1
      REGISTRY_INFO="${2:-}"
      REG_USER="${3:-}"
      REG_PASS="${4:-}"
      if [[ -z "$REG_USER" || -z "$REG_PASS" ]]; then
          echo "Error: Registry info requires a username and password. Format: -registry [registry:port username password]"
          echo "Use '--help' for usage."
          exit 1
      fi
      shift
      shift
      shift
      shift
      ;;
    *)
      echo "Invalid argument: $1"
      echo
      ;;
  esac
  shift
done

check_root_privileges
os_check

# -- Argument Validation -- #
if [[ $INSTALL_MODE -eq 1 ]]; then 
  if [[ $UNINSTALL_MODE -eq 1 || $SAVE_MODE -eq 1 ]]; then 
    echo "Error: install, offline-prep, or uninstall cannot be used together."; exit 1; fi
fi
if [[ $UNINSTALL_MODE -eq 1 ]]; then 
  if [[ $INSTALL_MODE -eq 1 || $SAVE_MODE -eq 1 ]]; then 
    echo "Error: install, offline-prep, or uninstall cannot be used together.";exit 1; fi
  if [[ $PUSH_MODE -eq 1 || $REGISTRY_MODE -eq 1 ]]; then
    echo "Error: push or registry cannot be used with uninstall."; exit 1; fi
fi
if [[ $SAVE_MODE -eq 1 ]]; then 
  if [[ $INSTALL_MODE -eq 1 || $UNINSTALL_MODE -eq 1 ]]; then 
    echo "Error: install, offline-prep, or uninstall cannot be used together."; exit 1; fi
  if [[ $PUSH_MODE -eq 1 || $REGISTRY_MODE -eq 1 ]]; then
    echo "Error: push or registry cannot be used with save."; exit 1; fi
fi
if [[ $PUSH_MODE -eq 1 ]]; then 
  if [[ $SAVE_MODE -eq 1 || $UNINSTALL_MODE -eq 1 ]]; then
    echo "Error: save or uninstall cannot be used with push."; exit 1; fi
fi
[[ ! -f $base_dir/minio-save.tar.gz ]] || AIR_GAPPED_MODE=1

# -- Main Logic -- #

echo "### MinIO Installer Started - $(date) ###"
display_args
if [[ $AIR_GAPPED_MODE -eq 1 ]]; then
  echo "  Extracting minio-save.tar.gz"
  tar -xzf $base_dir/minio-save.tar.gz
fi
if [[ $INSTALL_MODE -eq 1 ]]; then
  echo "###     MinIO Installation Starting"
  install_minio
fi
if [[ $SAVE_MODE -eq 1 ]]; then
  echo "###     MinIO Save Starting"
  offline_prep
fi
if [[ $UNINSTALL_MODE -eq 1 ]]; then 
  echo "###     MinIO Uninstallation Starting"
  uninstall_minio
fi
echo "### MinIO Installer Finished - $(date) ###"

